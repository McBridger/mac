# Итоги Великого Рефакторинга

## 1. Диагноз: Архитектурный Кризис

Изначально проект представлял собой гремучую смесь из глобальной шины событий (`EventBus`), `async/await` и `Actor`'ов. Этот подход, хоть и казался простым, порождал хаос:

*   **Неявные зависимости:** Компоненты общались через глобального посредника, делая поток данных невидимым и непредсказуемым. Было невозможно понять, кто отправляет событие и кто (и в каком порядке) его получает.
*   **Гонки состояний:** Асинхронная инициализация сервисов (`BluetoothManager`) в `App.swift` создавала "мины замедленного действия", когда `ViewModel` мог начать работу до того, как его зависимости были готовы.
*   **Ад `Swift Concurrency`:** Попытки скрестить `nonisolated` мир делегатов `CoreBluetooth` с `actor`-изолированным кодом приводили к бесконечной череде ошибок компиляции, связанных с `Sendable` и пересечением границ акторов.

## 2. Стратегия: Выжечь и Перестроить

Был принят радикальный план по полному отказу от `EventBus` в пользу современной, безопасной и явной архитектуры на базе `Swift Concurrency`.

**Цель:** Заменить неявные связи через шину на прямые, типизированные и асинхронные потоки данных (`AsyncStream`).

## 3. Процесс Рефакторинга: Хроники Битвы

Мы прошли через несколько итераций, каждая из которых решала новый пласт проблем, вскрываемых компилятором.

### Шаг 1: Ампутация `EventBus` из Сервисов

*   **`BluetoothManager` и `ClipboardManager`** были излечены от зависимости к `EventBus`.
*   Вместо отправки событий в шину, каждый сервис теперь предоставляет публичные, `nonisolated` `AsyncStream`'ы (`powerState`, `connectionState`, `messages` и т.д.). Это сделало их API явным и потокобезопасным.

### Шаг 2: Перестройка `ViewModel` и `App`

*   **`AppViewModel`** был переключен с прослушивания `EventBus` на прямую подписку на `AsyncStream`'ы от сервисов. Зависимости (`BluetoothManager`, `ClipboardManager`) теперь внедряются явно через `init`, делая архитектуру прозрачной.
*   **`App.swift`** был полностью переписан для корректной обработки асинхронной инициализации. Вместо опасных хаков (`UnsafeTaskResult`) теперь используется стандартный для `SwiftUI` подход с `.task` модификатором и опциональным `ViewModel`, что гарантирует отсутствие гонок состояний при запуске.

### Шаг 3: Укрощение `CoreBluetooth` и `Actor`'ов

Это была самая сложная часть, потребовавшая нескольких попыток:

1.  **Первая попытка (`@MainActor`):** Идея сделать прокси-делегат `@MainActor`'ом провалилась, так как это создало новые проблемы с доступом к `actor`-изолированным свойствам.
2.  **Вторая попытка (`@unchecked Sendable`):** Это был костыль, который обманывал компилятор, но не решал проблему по существу и оставлял потенциальные дыры в безопасности.
3.  **Финальное решение (Извлечение `Sendable`-типов):** Мы пришли к единственно верному решению. `CBPeripheralDelegateProxy` остался `nonisolated` классом. В его методах мы извлекаем `Sendable`-значения (`UUID`, `Data`, `CBManagerState`) из `non-Sendable` объектов `CoreBluetooth` *перед* созданием `Task`. В асинхронный `Task` передаются уже безопасные данные, а вызовы, требующие `non-Sendable` объектов (как `peripheral.respond`), остаются в синхронном `nonisolated` контексте.

## 4. Итог: Чистая и Предсказуемая Архитектура

В результате мы получили:

*   **Явные зависимости:** Потоки данных легко отслеживаются от сервиса к `ViewModel`.
*   **Безопасность `Concurrency`:** Все проблемы с `Sendable` и изоляцией акторов решены на уровне компиляции.
*   **Тестируемость:** Компоненты стали независимыми и их легко мокировать для тестов.
*   **Надежность:** Отсутствие гонок состояний и неявных связей делает приложение значительно стабильнее.

Проект прошел через огонь, воду и медные трубы `Swift Concurrency`, но вышел из этой битвы закаленным, чистым и правильным.

## 5. Эпилог: Битва за Стабильность UI

Казалось бы, победа была полной. Но после рефакторинга проявился новый враг — гонка состояний на уровне SwiftUI. Приложение выдавало ошибки `didChangeAttributedTitle` и `Unable to obtain a task name port right`, что указывало на проблемы с жизненным циклом `MenuBarExtra`.

**Проблема:** Логика инициализации `AppViewModel` находилась внутри `InitializerView`, которая уничтожалась сразу после завершения инициализации. Это приводило к тому, что SwiftUI пытался одновременно рендерить два разных состояния, вызывая внутренние сбои.

**Решение:**

*   **Централизация логики:** Вся асинхронная инициализация была перенесена из `InitializerView` напрямую в `App.swift` с использованием модификатора `.task`, примененного к корневой `View` внутри `MenuBarExtra`.
*   **Удаление `InitializerView`:** Этот класс был удален как излишний и порождающий проблемы.
*   **Стабилизация UI:** Для более плавной загрузки `Text("Loading...")` был заменен на `ProgressView`.
*   **Главный поток:** Чтобы избежать ворнингов о публикации изменений из фоновых потоков, `.task` был помечен аннотацией `@MainActor`.

В результате этих финальных штрихов мы добились не только архитектурной чистоты, но и полной стабильности UI, окончательно победив все гонки состояний.